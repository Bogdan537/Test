<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="Kurs">
        <item>Теорія тестування</item>
    </string-array>
    <string-array name="Kurs_content">
        <item>Тестування програмного забезпечення (англ. Software Testing) — це процес технічного дослідження, призначений для виявлення інформації про якість продукту відносно контексту, в якому він має використовуватись. Техніка тестування також включає як процес пошуку помилок або інших дефектів, так і випробування програмних складових з метою оцінки.\n
Тестування програмного забезпечення - процес перевірки відповідності заявлених до продукту вимог і реально реалізованої функціональності, здійснюваний шляхом спостереження за його роботою в штучно створених ситуаціях і на обмеженому наборі тестів, обраних певним чином.\n
Може оцінюватись:\n
- відповідність вимогам, якими керувалися проектувальники та розробники\n
- правильна відповідь для усіх можливих вхідних даних\n
- виконання функцій за прийнятний час\n
- практичність\n
- сумісність з програмним забезпеченням та операційними системами\n
- відповідність задачам замовника.\n

.</item>
    </string-array>
    <array name="Kurs_image_array">
        <item>@drawable/covernew</item>
    </array>

    <string-array name="princips">
        <item>TESTING PRINCIPLES</item>
    </string-array>
    <string-array name="princips_content">
        <item>Принцип 1. Тестування виявляє присутність дефектів.
Тестування виявляє, що дефекти присутні, але не може запевнити, що дефекти відсутні. Тестування зменшує ймовірну кількість незнайдених дефектів, та якщо дефектів не знайдено, це не гарантує їхньої відсутності.\n
Принцип 2. Вичерпне тестування неможливе.
Тестування всього (усіх комбінацій введень і передумов) є неможливе за виключенням тривіальних випадків. Замість намагань, протестувати все, використовується аналіз ризиків та пріоритетів, що допомагає провести цілеспрямоване тестування.\n
Принцип 3. Раннє тестування.
Тестування розпочинається так швидко як це можливо і фокусується на визначенні цілей.\n
Принцип 4. Групування дефектів.
Зусилля тестування фокусуються пропорційно до очікуваної і отриманої густини дефектів по модулях. Декілька модулів зазвичай містять більшість дефектів, знайдених під час дорелізного тестування, або повязаних в основному з недосконалостями операційних систем.\n
Принцип 5. Парадокс пестицидів.
Якщо тестування повторюється, то один набір тест кейсів не буде знаходити нові дефекти. Уникнути “парадокс пестицидів” можна регулярною перевіркою, оновленням, та дописуванням нових тестів.\n
Принцип 6. Тестування залежить від контексту.
Тестування відрізняється в залежності від контексту продукту. Для прикладу, програмне забезпечення з критичним захистом тестується інакше ніж комерційний сайт.\n
Принцип 7. Відсутність дефектів оманлива.
Знаходження та виправлення дефектів не допомагає, якщо система непридатна і не задовільняє потреб та очікувань користувача.</item>
    </string-array>
    <array name="princips_image_array">
    <item>@drawable/princips</item>
    </array>

    <string-array name="soft">
        <item>SDLC</item>
        <item>Waterfull-modell</item>
        <item>V-model</item>
        <item>Spiral model</item>
        <item>Agile</item>
        <item>Scrum</item>
        <item>Kanban</item>
    </string-array>
    <string-array name="soft_content">
        <item>\nSoftware Development Life Cycle Model — модель життєвого циклу розробки програмного забезпечення.\nТипові фази розробки програмного забезпечення:\n
Прийняття рішення — що плануємо розробляти.\n
Дизайн — як це буде реалізовано.\n
Розробки — створюємо продукт відповідно до дизайну.\n
Представлення — представлення створеного продукту.\n</item>
        <item>\nЦе SDLC модель, де процес розробки відбувається послідовно, робота над наступною фазою розпочинається тільки після завершення робіт у попередній фазі.Це модель, за якою розробляється продукт.\n
Вимоги (Requirements)\n
Проектування (Design)\n
Реалізація (Implementation)\n
Верифікація (Testing/Verification)\n
Супровід (Maintenance)\n
            Фази Waterfall:\n
Requirements Формування Вимог — це фаза створення системних і software requirements (вимог до ПЗ).\n
Design Дизайн — це фаза створення архітектури системи, графічного технічного дизайну.\n
Implementation Імплементація — це фаза конструювання, впровадження чи написання програм системи.\n
Verification Phase Верифікація — це фаза перевірки чи система працює так, як очікується. Валідація – це перевірка чи система розробляється так, як заплановано.\n
Maintenance Супровід — це фаза підтримки і супроводу продукту на кінцевому клієнтському середовищі.\n
Використання:\n
У проектах, де необхідні дуже жорсткі процеси і критично високий рівень якості, наприклад медичні, авіа, космічні проекти. Зазвичай це великі і довготривалі проекти.\n
Waterfall модель не ефективна для комерційних проектів, які вимагають швидкої реакції на потреби ринку.\n
Розповсюдженість: використовується у критичних для життя людини проектах з багаторівневим забезпеченням якості.</item>
        <item>\nV-Model - це SDLC модель названа за V-подібною діаграмою проходження фаз, де ліва частина зверху вниз – це процеси визначення проекту, низ (середина V) – це Coding (написання коду програми), а права частина знизу вверх – інтеграція частин системи паралельно з тестуванням відповідного рівня інтергації. Модель визначає відповідність між процесами, що на одному рівні зліва і справа.\n
Також, V позначає процеси Verification та Validation, що виникають під час правої частини моделі, щодо її лівої частини.\n
Verification = це процес перевірки і підтвердження, з наданням доказів, що продукт відповідає специфікаціям.\n
Validation - це процес перевірки і підтвердження, з наданням доказів, що продукт відповідає своїм проектованим функціям чи цілям використання.\n
        Фази V-Model:\n
Requirements Analysis Аналіз вимог — фаза детального аналізу вимог.\n
Звязок з Acceptance Testing: Планування Acceptance Test Design робиться на основі Business Requirements.\n
System Design Дизайн системи — фаза, де інтенсивно аналізуються вимоги на основі яких створюється графічний і технічний дизайн продукту.\n
Звязок з System Testing: Test Plan створюється на основі Requirements і System Design.\n
Architecture Design Проектування архітектури — фаза, коли розглядаються кілька технічних підходів, розробляються архітектурні документи і вибирається підхід реалізації відповідно до фінансових і технічних можливостей. System Design розбивається на компоненти різної функціональності, чітко визначається передача даних і зв’язки між внутрішніми компонентами системи і зовнішніми системами. Розробляється High Level Design.\n
Звязок з Integration Testing: Інтеграційні тести створюються на основі High Level Design.\n
Module Design Проектування компонентів — фаза проектування компонентів системи таким чином, щоб компоненти між собою поєднувалися і конфліктів між ними не виникало. Розробляється Low Level Design.\n
Звязок з Unit Testing: Юніт тести створюються на основі Low Level Design.\n
Coding Написання програмного коду — фаза розробки програм за допомогою найбільш відповідних до системних і архітектурних вимог мов програмування. Написання коду повинно відбуватись на основі інструкцій і стандартів, код проходить чисельні перегляди і оптимізується для покращення продуктивності перш ніж фінальна версія реалізовується у виробництві.\n
Unit Testing Тестування компонентів — фаза виконання Unit Test-ів, вони виконуються на рівні коду; дуже цінні, допомагають усунути максимум помилок і проблем системи на дуже ранньому етапі, але не виявляють і не усувають всіх проблем системи. Виконується розробниками.\n
Integration Testing Інтеграційне тестування — фаза виконання інтеграційних тестів для виявлення проблем співіснування різних компонентів системи і їх взаємодії між собою. Виконується розробниками.\n
System Testing Тестування системи — фаза повного тестування цілої системи, а також її взаємодії із зовнішніми системами чи компонентами. Зазвичай, це найбільш маcштабна фаза тестування із залученням тест інженерів.\n
Acceptance Testing Приймальне тестування — фаза тестування системи у середовищі користувача. Може виконуватись клієнтом чи тест інженерами, але в клієнтському середовищі.\n
V-Model можна використовувати, в таких випадках:\n
    Вимоги добре визначені, задокументовані і зафіксовані.\n
    Формулювання продукту стабільне.\n
    Технології не динамічні і проектна команда їх добре знає.\n
    Немає двозначних чи невизначених вимог.\n
    Проект короткий.\n
Використання:\n
V-model також використовується у медичних чи державних проектах.\n
Більшості організацій відомо про цю модель — на її прикладі можна пояснювати, що планується робити для клієнта, пояснювати фази і активності на них, як описано вище.</item>
        <item>\nЦе спіральна ітеративна SDLC модель, де протягом 4-х фаз розробляється прототип, набір фаз повторюється ітерація за ітерацією із наростанням кількості роботи на кожному наступному циклі і в кінці кожної ітерації розробляється новий більш детальний прототип аж до фінального. Ціна проекту зростає із часом, із кожною наступною ітерацією, оскільки наростає кількість роботи.\n
            Фази Spiral-Model:\n
Determine Objectives Визначення цілей і завдань — фаза аналогічна Requirements Phase в попередніх моделях.\n
Identify Risks and Resolve Risks Визначення ризиків і вирішення ризиків — фаза визначення ризиків, таких як: невчасна здача продукту або продукт не відповідає потребам клієнта, недостача ресурсів і т.д.\n
Development and Test Розробка і тестування — фаза розробки та тестування.\n
Plan the Next Iteration Планування наступної ітерації — фаза планування робіт наступної ітерації.\n
     Використання:\n
Spiral Model використовується у великих, дорогих і складних проектах, наприклад у військових США спіральна модель використовується для програми Future Combat Systems (симстеми майбутніх боїв). Можна сказати, що ця модель є поєднанням ітеративної / прототипної моделі, де розробка іде ітераціями-періодами і Waterfall.</item>
        <item>\nБуквально — гнучкий. Це радше не SDLC модель розробки програмного забезпечення, а підхід: гнучкий підхід до виконання завдань замовника, де вимоги можуть змінюватися, результат видимий швидко і є предметом до обговорення і покращення, робота гнучко реорганізується на користь ефективності й швидкості результату, а не на користь дотримання процесу.\n
            Agile розуміють як використання на проекті гнучких підходів, таких як Scrum, Kanban, Extreme Programming та інших, в яких вимоги і рішення розвиваються на основі співпраці між собою учасників самоорганізованої, крос-функціональної команди.
            Це сприяє адаптивному плануванню, еволюційному розвитку, ранньому наданню продукту, постійному вдосконаленню, дозволяє швидко і гнучко реагувати на зміни.\n
Sprint\n
Це відрізок часу, який береться для виконання сформованого списку завдань. Рекомендується брати 1-4 тижні (тривалість визначається командою один раз).\n
Backlog\n
Це список всіх робіт. Можна сказати, що це проектний щоденник загального користування.\n
Plan the Next Iteration Планування наступної ітерації — планування робіт для наступної ітерації.\n
Product Backlog Список завдань по продукту — створення повного списку всіх загальних завдань, при реалізації яких ми отримаємо кінцевий продукт.\n
Sprint Planning Планування спринта — планування завдань на Спринт, в якій береться кілька найважливіших загальних завдань з Product Backlog, які реалістично виконати протягом періоду стринта (1-4 тижні), ці завдання в свою чергу розбиваються на дрібніші і детальніші робочі завдання. Як результат, створюється Sprint Backlog.\n
Sprint Backlog Список завдань на спринт — це список завдань, який визначено і погоджено на найближчий звітний період. Завдання в спринт-беклог беруться з Product Backlog.\n
Sprint Спринт — це період, коли завдання виконуються: пишеться код, тестується, виправляються помилки, перетестовуються і т.д. Що не зроблене в поточному спринті потрапляє або в Product Backlog, або в наступний спринт, залежно від важливості. Спринти повторюються ітеративно (циклічно).\n
Potentially Shippable Software Програмне забезпечення потенційно готове до відправки клієнту — в кінці спринту отримується готовий до показу клієнту продукт, демонструється клієнту, отримуються зауваження, що формує роботу на наступний спринт. Якщо клієнт повністю задоволений, чи поспішає — може забрати вже цей продукт.\n
Agile Manifesto\n
Agile маніфест базується на 10 принципах:\n
Задоволення потреб клієнта за допомогою раннього і постійного надання цінного програмного забезпечення.\n
Вітаються зміни вимог, навіть на пізніх фазах розробки.\n
Робоча програма віддається клієнту часто (тижні, а не місяці).\n
Близька, щоденна співпраця між людьми бізнесу та розробниками.\n
Проекти будуються навколо мотивованих індивідів, яким довіряють.\n
Особиста розмова є найкращою формою спілкування.\n
Робоча програма є основним критерієм прогресу.\n
Постійна розробка, що в змозі підтримувати сталий темп.\n
Постійна увага до технічної досконалості і хорошого дизайну.\n
Простота — мистецтво максимізації обсягу роботи, яку не треба робити – важлива!\n
            Слід зазначити, що гнучкі методології Agile спочатку проектувалися для продуктів, вимоги до розробки яких змінюються протягом всього процесу їх створення. В цьому і полягає їх ключова відмінність від класичних методологій, зокрема, моделі Waterfall, для яких характерні довгі узгодження з приводу найменших змін в проекті.\n
      Якщо говорити про переваги і недоліки гнучких методологій в цілому, то головним мінусом стане “плаваюча” оцінка термінів розробки та бюджету, що постійно змінюються паралельно коригування вимог. До плюсів же Agile-методів, безумовно, варто віднести низькі терміни виробництва продукту і відсутність простоїв на час погодження проектної документації.\n</item>
        <item>\nТермін взятий з регбі, який означає сутичку навколо м’яча.Це метод управління проектами побудований на принципах управління часом. Основною особливістю є залученість в процес всіх учасників, причому у кожного учасника є своя певна роль. Суть в тому, що не тільки команда працює над вирішенням завдання, але й ті, кому цікаво рішення завдання: не просто поставили її і забули, а безперервно працюють з командою, і ця робота не означає тільки постійний контроль.\n
        Product Owner - Власник продукту. Людина, яка безпосередньо зацікавлена у якісному кінцевому продукті і розуміє, як продукт повинен виглядати / працювати. Ця людина не працює в команді, працює на стороні замовника / клієнта (це може бути як інша компанія, так і інший відділ), але ця людина працює з командою. І це та людина, яка розставляє пріоритети для завдань в спринті.\n
Scrum Master - Людина, яку можна назвати керівником проекту, хоча це не зовсім так. Головне, що це людина, “заражена Scrum-бацилою” на стільки, що несе її як своїй команді, так і замовнику, й відповідно стежить за тим, щоб усі принципи Scrum дотримувалися.\n
Scrum Team - Команда, яка приймає всі принципи Scrum і готова з ними працювати.\n
Sprint Backlog - Cписок робіт, який визначила команда і погодила з Product Owner (власником продукту) на найближчий звітний період (Sprint). Завдання в Sprint Backlog беруться з Product Backlog.\n
Sprint Planning - Буквально — планування спринта. Meeting (нарада), на якому присутні всі (Scrum Team, Scrum-Master, Product Owner). Протягом цієї наради Product Owner (власник продукту) визначає пріоритети завдань, які він хотів би побачити виконаними після закінчення Спринта. Команда оцінює за часом, скільки з бажаного вони можуть виконати. У підсумку виходить список завдань, який не може змінюватися протягом Спринта і до кінця Спринта повинен бути повністю виконаний.\n
Bug - Помилка\n
Task - Завдання\n
Daily Scrum Meeting - Буквально — щоденна Скрам зустріч. Щоденна нарада, де вся команда з або без продакт овнера зустрічається, щоб обговорити, що зроблено, що робиться, що буде робитись, які є проблеми, хто їх може вирішити.\n
Sprint Retrospective - Нарада в кінці спринта, на якій розглядається, що було добре і варто продовжувати, що було погано і варто змінити, які є конструктивні пропозиції, що варто застосувати.\n
Sprint Review - Демонстрація робочої версії продукту Product Owner -у для обговорення, отримання вражень і побажань\n
            Процес Scrum:\n
Основою Scrum є Sprint, протягом якого виконується робота над продуктом. По закінченню Спринта має бути отримана нова робоча версія продукту. Sprint завжди обмежений у часі (1-4 тижні) і має однакову тривалість протягом усього життя продукту.\n
Перед початком кожного Спринта проводиться Sprint Planning, на якому проводиться оцінка вмісту Product Backlog і формування Sprint Backlog, який містить завдання (User Story, Bugs, Tasks), які повинні бути виконані в поточному Спринті. Кожен Спринт повинен мати мету, яка є мотивуючим фактором і досягається за допомогою виконання завдань з Sprint Backlog.\n
Кожен день проводиться Daily Scrum, на якому кожен член команди відповідає на питання “Що я зробив вчора?”, “Що я планую зробити сьогодні?” “Які перешкоди у своїй роботі я зустрів?”. Завдання Daily Scrum — визначення статусу і прогресу роботи над Sprint, раннє виявлення перешкод, які виникли, вироблення рішень по зміні стратегії, необхідних для досягнення цілей поточного Спринта.\n
По закінченню Спринта проводять Sprint Review і Sprint Retrospective, завдання яких оцінити ефективність (продуктивність) команди в минулому Спринті, спрогнозувати очікувану ефективність (продуктивність) в наступному Спринті, виявити наявні проблеми, оцінити ймовірності завершення всіх необхідних робіт по продукту та інше.\n
Важливі особливості, котрі буває забуваються!!!\n
Часто можна почути, що Scrum не працює, або працює гірше, аніж очікувалося. Необхідно зауважити, що найчастіше так відбувається по одній з наступних причин:\n
SCRUM застосовується невірно або неповністю. Згідно авторів Scrum, емпіричний досвід є головним джерелом достовірної інформації. Необхідність повного і точного виконання Scrum вказана в The Scrum Guide і обумовлена нетиповою організацією процесу, відсутністю формального лідера і керівника.\n
Недооцінена важливість роботи щодо забезпечення мотивації команди. Одним з основних принципів Scrum є самоорганізована, багатофункціональна команда. Згідно з дослідженнями соціологів, чисельність ініціативних співробітників, здатних на самоорганізацію не перевищує 15% від працездатного населення. Таким чином, лише невелика частина співробітників здатна ефективно працювати в Scrum без істотних зміни у ролях Scrum Master і Product Owner, що суперечить ідеології Scrum, і потенційно призводить до невірного або неповного використання підходу.\n
Підхід застосовується для продукту, вимоги до якого суперечать ідеології Scrum. Scrum відноситься до сімейства Agile, тому Scrum вітає зміни у вимогах в будь-який момент (Product Backlog може бути змінений в будь-який момент). Це ускладнює використання Scrum у fixed cost (фіксована вартість)/fixed-time(фіксований час) проектах. Ідеологія Scrum стверджує, що заздалегідь неможливо передбачити всі зміни, таким чином немає сенсу заздалегідь планувати весь проект, обмежившись тільки just-in-timе (тільки в цей час) плануванням, тобто планувати тільки ту роботу, яка повинна бути виконана в поточному Sprint.\n
Існують і інші обмеження.\n
Переваги та недоліки Scrum\n
Scrum володіє досить привабливими перевагами. Scrum орієнтований на клієнта, адаптивний. Scrum дає клієнту можливість робити зміни у вимогах в будь-який момент часу (але не гарантує того, що ці зміни будуть виконані). Можливість зміни вимог приваблива для багатьох замовників.\n
Scrum досить простий у вивченні, дозволяє економити час за рахунок виключення не критичних активностей. Scrum дозволяє отримати робочий продукт в кінці кожного Спринта.\n
Scrum робить наголос на самоорганізованій багатофункціональній команді, здатній вирішити необхідні завдання з мінімальною координацією. Це особливо привабливо для малих компаній і стартапів, так як позбавляє від необхідності найму або спеціалізованого навчання персоналу керівників.\n
В Scrum не прийнято, наприклад, створення плану комунікацій та реагування на ризики. Складно або неможливо формально (юридично або адміністративно) протидіяти порушенням правил Scrum.\n
Іншою слабкою особливістю Scrum є наголос на самоорганізованій багатофункціональній команді. При уявному зниженні витрат на координацію команди, це призводить до підвищення витрат на відбір персоналу, його мотивацію, навчання. За певних умов ринку праці, формування повноцінної, ефективної Scrum команди може бути неможливим.\n</item>
        <item>\nБуквально означає білборд, рекламний щит.Метод Канбан означає систему візуального управління процесом (для цього використовується дошка з завданнями на різних фазах), яка вказує що виробляти, коли виробляти, і як багато виробляти.Основний наголос в цьому підході робиться на “доставці клієнту якраз вчасно” та униканні перевантаження членів команди. При цьому підході, процес від опису завдання до доставки результатів її виконання користувачу наочно показується учасникам процесу, і члени команди можуть брати завдання з черги.\n
        Kanban являє собою повну протилежність Скраму. Його відмінність — в способі розподілу завдань: кожен, хто працює в проектній команді, може взяти на себе лише обмежену кількість завдань, при цьому вибір завдань він здійснює самостійно, а не за чиєюсь вказівкою. Такий метод дозволяє значно знизити час, що витрачається на розробку, але скористатися всіма його перевагами зможе далеко не кожна проектна команда.\n
        Фази Канбан:\n
TO DO\n
Зробити — завдання на проекті максимально роздрібнюються таким чином, щоб одна людина могла взяти одне завдання і у максимально короткий термін її виконати.\n
DOING\n
Роблю — члени команди вибирають собі завдання, і починаючи над ними працювати переносять у середню частину дошки.\n
DONE\n
Зроблено — коли завдання виконане, виконавець переносить його у саму праву частину дошки.\n
4 основних принципи Канбан:\n
Почніть з того що  Ви маєте зараз! Метод Канбан не описує конкретний набір ролей чи кроків процесу. Він стартує з ролями і процесами що є у вас зараз, і стимулює постійні інкрементні та еволюційні зміни в системі. Канбан — це метод управління змінами.\n
Погодьтесь домагатись інкрементних, еволюційних змін! Організація (чи команда) повинна погодитись що постійні, інкрементні зміни — це спосіб покращити систему, і зробити так щоб ці покращення прижились. Глобальні зміни можуть виглядати більш ефективними, але мають більший ризик провалу, через опір та страх змін в організації. Канбан заохочує постійні невеликі зміни до поточної системи.\n
 Поважайте поточний процес, ролі, відповідальності та посади! Дуже ймовірно, що організація має деякі елементи що працюють задовільно, і їх варто зберегти. Канбан намагається уникнути страхів, домовляючись поважати поточні ролі, відповідальності та посади, з метою отримати ширшу підтримку.\n
 Лідерство на всіх рівнях! Лідерські дії на всіх рівнях, від окремих працівників і аж до старшого менеджменту — схвалюються.\n
6 ключових практик Канбану:\n
   1. Візуалізуйте\n
Візуалізація процесів роботи допомагає в правильному розумінні змін, що плануються і допомагає впроваджувати їх згідно з планом.
Типовим способом візуалізувати процес роботи є використання дошки з колонками і картками. Колонки на дошціі позначають різні фази процесу роботи. Таку дошку, або її модифікацію, можна створити в JIRA.\n
    2. Обмежуйте завдання у процесі виконання\n
Обмеження завдань у процесі виконання – це використання системи ‘перетягування завдань’ по дошці. Система ‘перетягування завдань ‘працює як один з головних стимулів до постійних покращень в системі.
Система ‘перетягування завдань’ може бути реалізована, як система Kanban, CONWIP, DBR чи якийсь інший варіант. Критичним елементом є те, що робота, котра перебуває в стані виконання на кожному кроці
робочого процесу, є обмеженою, і що нова робота ‘перетягується’ в кожен розділ / фазу дошки, коли з’являється місце в колонці.\n
    3. Керуйте потоком\n
Кожен перехід між станами в потоці моніториться, вимірюється і звітується. Активне управління потоком дозволяє оцінити позитивні та негативні ефекти змін у системі.\n
    4. Зробіть політики явними\n
Поки механізм чи процес не стане явним, часто важко чи неможливо здійснювати обговорення щодо його вдосконалення. Без явного розуміння, як все працює, будь-які обговорення проблем стають емоційними та суб’єктивними. З явним розумінням можливо перейти до більш раціональних, емпіричних та об’єктивних обговорень проблем.\n
    5. Постійне покращення\n
Організації що не створили другий рівень зворотнього зв’язку — перегляд операцій, — зазвичай не бачать вдосконалення процесу поза локалізованим рівнем команди.\n
    6. Постійне покращення\n
Вдосконалюйте процес на проекті співпрацюючи, розвивайтесь експериментально, використовуючи моделі та наукові методи. Kanban пропагує малі поступові, постійні та еволюційні зміни які приживаються. Коли команди мають спільне розуміння теорій про роботу, процес, ризики, вони більш ймовірно будуть здатними виробити спільне розуміння проблем та запропонувати вдосконалення які будуть результатом консенсусу.</item>
    </string-array>
    <array name="soft_image_array">
        <item>@drawable/sdlc</item>
        <item>@drawable/waterful</item>
        <item>@drawable/v_model</item>
        <item>@drawable/spiral</item>
        <item>@drawable/agile</item>
        <item>@drawable/scrum</item>
        <item>@drawable/kanban</item>
    </array>

    <string-array name="requirements">
        <item>Requirements</item>
        <item> Requirement Structural Elements</item>
        <item> Requirement Terminology</item>
        <item> Requirement Types</item>
        <item>User Stories</item>
        <item> Requirements Characteristics</item>

    </string-array>
    <string-array name="requirements_content">
        <item>Requirement (вимога) — це одинична задокументована потреба у тому, що конкретний продукт чи послуга повинні бути або виконувати. Найчастіше використовується формально при побудові систем чи розробці програмного забезпечення.\n
            Являє собою твердження, яке ідентифікує певний необхідний атрибут, можливість, характеристику або властивість системи потрібну для того, щоб система мала цінність і корисність для користувача.\n
        SRS/System Requirement Specification\n
Специфікація системних вимог — документ, що містить структуровані, правильно оформлені і максимально уточнені вимоги.\n
      Процес розробки програмного забезпечення повинен починатися з договору виконавця і клієнта про те, які цілі завершене програмне забезпечення повинно задовільняти. Ця угода, в формі SRS, це спільна робота замовника та виконавця. Це важливо, оскільки, як правило, ні замовник, ні виконавець не можуть написати хороший SRS поодинці.\n
Типові причини створення неякісних вимог:\n
а) Клієнти, як правило, не розуміють процес проектування і розробки програмного забезпечення досить добре, щоб написати якісні вимоги до продукту.\n
б) Виконавці зазвичай не розуміють проблем клієнта і поле його діяльності достатньо добре, щоб визначити вимоги для задовільної системи.</item>
        <item>Основні елементи вимог:\n
Type\n
ID\n
Name / Summary / Title\n
Event Flow\n
Pre-conditions \n
Post-conditions\n
Dependencies\n
Priority\n
Status\n
Type — вид вимог, наприклад:\n
Functional — функціональні;\n
Non-functional — нефункціональні;\n
Interface — вимоги до інтерфейсу;\n
Operational — операційні.\n
Зазвичай вимоги в документі групуються по типу.\n
ID — ідентифікаційний номер кожної вимоги повинен бути унікальним на всьому проекті і незмінним, по ньому можна звернутись до вимоги (дати посилання в описі помилки, тестовому випадку, листі чи будь-якому іншому документі, обговоренні).n
Name / Summary / Title — ім’я, короткий зміст чи назва.n
Event Flow — послідовність подій.\n
Pre-conditions — передумови або що має бути виконане до виконання вимоги.\n
Post-conditions — післяумови або що має бути виконане після виконання вимоги.\n
Dependencies — залежності цієї вимоги від іншої(-их) або її взаємодія з іншими вимогами.\n
Priority — приорітет вимоги. Приорітизація вимог використовується в управлінні продуктом програмного забезпечення для визначення того, які саме вимоги до програмного продукту повинні бути включені в певний реліз, чи інакше реалізовані у першу чергу.\n
Рівні вимог можуть позначатися числами або через пріоритетність:\n
High — високий;\n
Medium — середній;\n
Low — низький.\n
Status — статус вимоги надає інформацію про вимогу, бувають:\n
New — новий;\n
Approved — затверджений;\n
Declined — відмінений;\n
Postponed — відкладений;\n
Duplicates — дублює інший.</item>
        <item>Формат побудови вимог\n
        Ключові слова, терміни та їх значення:\n
MUST — слово, або терміни “REQUIRED” or “SHALL”, означає вимогу абсолютного дотримання специфікації.\n
MUST NOT — цей вираз, чи ось цей “SHALL NOT”, означає вимогу абсолютного заперечення специфікації.\n
SHOULD — слово, або прикметник “RECOMMENDED”, означає, що може існувати вагома причина, у окремих випадках, яка дозволяє ігнорувати вимогу частково, але випадок повинен бути зрозумілим та виваженим перед вибором іншого варіанту.\n
SHOULD NOT — цей вираз, чи вираз “NOT RECOMMENDED”, означає, що може існувати вагома причина, у окремих випадках, коли поведінка системи може бути прйнятною, а навіть корисною, але випадок повинен бути зрозумілим та виваженим перед виконанням будь якої дії описаної на маркуванні.\n
MAY — це слово, або прикметник “OPTIONAL,” означає, що ця функція чи дія можуть бути використані на розсуд користувача.\n
FUTURE — означає, що цілі представлені до розгляду і можуть бути прийнятими або ні.</item>
        <item>Вимоги до програмного забезпечення — набір вимог щодо властивостей, якості та функцій програмного забезпечення, що буде розроблено, або знаходиться у розробці.\n
        2.3.1. Functional Requirements\n
Функціональні вимоги описують внутрішню функціональність системи, її поведінку: обчислення даних, обмін та керування даними, вивчення даних та інших конкретних функцій, які система повинна робити. Як правило, функціональні вимоги визначають, що система повинна робити, а нефункціональні — як система повинна виглядати.\n
2.3.2. Non-Functional Requirements\n
Нефункціональні вимоги описують не те, що софт буде робити, а те, як він буде робити це, наприклад, вимоги до продуктивності, до зовнішнішнього інтерфейсу, до обмежень дизайну та атрибутів якості. Нефункціональні вимоги важкі для тестування; тому, вони, як правило, оцінюються суб’єктивно.\n
2.3.3. Operational Requirements\n
Експлуатаційні вимоги описують, як система буде працювати і взаємодіяти з користувачами у їх середовищі, тобто як буде запускатись система, як логуватись, як працюватимуть засоби включити / виключити систему, засоби моніторингу, споживання ресурсів системою, резервування, доступність системи і т.д.\n
2.3.4. Recoverability Requirements\n
Відновлюваність — це можливість відновлення функцій і даних у разі збою.\n
Наприклад:\n
У разі, якщо додаток недоступний для користувачів (‘впав’) через збій системи, як швидко після виявлення збою повинне бути відновлене функціювання?\n
У разі пошкодження бази даних, до якого історичного моменту роботи вона повинна бути відновлена? Наприклад, має бути можливість відновити базу даних станом як на ‘не більше ніж за 1 годину’ до того, як сталася поломка.\n
Якщо сторона обробки (апаратне забезпечення, дані, місце резервного копіювання) знищується, як скоро повинен application (додаток) зможе бути відновленим?\n
2.3.5. Performance Requirements\n
Вимоги до продуктивності описують очікувані параметри продуктивності системи у термінах ‘не більше ніж’, ‘не менше ніж’. Наприклад, визначаються наступні параметри системи:\n
Response time (час відповіді) системи на queries (запити даних) і updates (оновлення даних).\n
Throughput (пропускна здатність).\n
Очікуваний рівень активності користувачів (наприклад, кількість транзакцій в годину, день чи місяць або циклічні періоди.\n
Очікуване максимальне навантаження, при якому система має праццюватиме нормально.\n
Специфічні вимоги до робочих характеристик, пов’язані з конкретними функціями, повинні бути вказані у функціональних вимогах.\n
2.3.6.Capacity Requirements\n
Вимоги ємності описують очікувані об’єми даних, що мають оброблятись та решта необхідних ємностей системи, чи є тенденції до розростання і передбачення цього розростання.\n
2.3.7. Retention Requirements\n
Вимоги до зберігання описують як довго (періоди часу) різні форми даних мають зберігатись і також вимоги до їх знищення.\n
Наприклад: система має зберігати інформацію про програму протягом 3 років.\n
Різні форми даних включають в себе: систему документації, записи аудиту, записи бази даних, записи доступу.\n
2.3.8. Interface Requirements\n
Вимоги до інтерфейсів описують очікувану роботу місць взаємодії з системою. Інтерфейси поділяються на:\n
Hardware Interfaces (інтерфейси ‘заліза’ — апаратного забезпечення) — це місця фізичної / апаратної взаємодії, необхідні для обслуговування системи, включають опис логічної структури, фізичні адреси і очікувану поведінку.\n
Software Interfaces (інтерфейси софта) — це місця програмної взаємодії з системою, що розробляється.\n
Communications Interfaces (інтерфейси комунікації) — це місця взаємодії з іншими системами чи приладами, можуть бути програмні і апаратні.</item>
        <item>User Stories —  це по суті вимоги, але прості для сприйняття клієнта.\n
            User Story — це одне або кілька речень написаних повсякденною або бізнес-мовою користувача або клієнта, які описують те, чого користувач або клієнт хоче досягти за допомогою програмного забезпечення. Це короткий опис того, як користувач, клієнт або інша особа буде використовувати систему, і яку вигоду при цьому отримає від конкретної функціональності. Таким чином, замість складних для розуміння клієнта Requirements Specifications, створюються короткі розповіді — User Stories — які забезпечують власнику продукту зрозумілий контекст і дозволяють ефективно керувати і приорітизувати список завдань.\n
Who? (Хто?) User Story\n
“Who?” в User Story — це хто хоче цю функціональність і отримує вигоду з неї. Зазвичай, використовується роль чи особа для того, щоб всі глибоко розуміли потреби і мотивації цього “Who”. Уникайте занадто загальних ролей (приклад: As a user I want… — Як користувач я хочу…); замість цього використовуйте ролі, що допомагають команді уявити для кого саме вони створюють продукт. В деяких User Stories  система виступає, як  “Who”. Навіть дуже технічні User Stories повинні описувати, що клієнт чи користувач отримує з цього.\n
What? (Що?) User Story\n
“What?” в User Story — це потреба, частина системи чи функціональність, яку хоче ‘Who’.Це те, що команда буде вбудовувати у software чи service (сервіс). ‘What’ (що)  має бути дуже чітке і ясне, щоб команда знала, що проектувати і створювати.\n
Why? (Чому?) User Story\n
“Why?” в User Story — це цінність для “Who”. Це основна мета для надання цього кієнту. Включення “Why” збагачує User Stories. “Why” — це важливий контекст, який допомагає команді проектувати рішення, що відповідають реальним потребам користувачів і споживачів. “Why” також критично важливе в Agile який є ціннісно-керованим підходом у розробці Software. “Why” (чому) центрує і тримає цінність на виду, допомагаючи Product Owner  визначати приоритети. Якщо не виходить знайти “Why” для User Story, можливо це випадок для якого немає жодної цінності.\n
        </item>
        <item>Хороші Software Requirement Specification (специфікації) мають бути:\n
Correct (корректні);\n
Unambiguous (однозначні);\n
Complete (завершені);\n
Consistent (консистентні);\n
Ranked for importance and / or stability (приорітизовані по важливості чи / або стабільності);\n
Verifiable (такі, що можна перевірити);\n
Modifiable (такі, що можна змінити);\n
Traceable (прослідковувані).\n
Наприклад:\n
      Не вказуйте яким чином ці вимоги мають виконуватись. В розділі надійності, дайте відповідь на питання: “Наскільки надійна повинна бути система”? Не вказуйте, які кроки будуть зроблені для забезпечення надійності.\n
      Відрізняйте preference (побажання) від вимог! Вимоги засновані на потребах бізнесу, preference (побажання) — ні. Якщо, наприклад, користувач вимагає спеціальної відповіді системи, але не має пов’язаних з бізнесом причин для цього, це вимога є preference (побажанням).\n</item>
         </string-array>
    <array name="requirements_image_array">
        <item>@drawable/requirements</item>
        <item>@drawable/elements</item>
        <item>@drawable/terminology</item>
        <item>@drawable/types</item>
        <item>@drawable/stories</item>
        <item>@drawable/characteristic</item>

    </array>

    <string-array name="uml">
        <item>UML</item>
        <item>UML Diagrams</item>
        <item>Use Case Diagrams</item>
    </string-array>
    <string-array name="uml_content">
        <item>UML — (англ. Unified Modeling Language) — уніфікована мова об’єктно-орієнтованого моделювання. \n Вона є невід’ємною частиною процесу розробки програмного забезпечення.\n UML Diagrams — діаграми написані (намальовані) мовою UML.\n</item>
        <item>UML діаграми поділяються на типи:\n
Структурні UML Діаграми:\n
Діаграма класів (Class Diagram)\n
Діаграма об’єктів (Object Diagram)\n
Діаграма компонентів (Component Diagram)\n
Діаграма композитів (Composite Structural Diagram)\n
Діаграма кооперацій (Collaboration)\n
Діаграма розгортання (Deployment Diagram)\n
Діаграма пакетів (Package Diagram)\n
Поведінкові UML Діаграми:\n
Діаграми взаємодії (Interaction Diagram) у свою чергу поділяються на:\n
Діаграма послідовності (Sequence Diagram)\n
Діаграма комунікації (Communication Diagram)\n
Діаграма огляду взаємодії (Interaction Overview Diagram)\n
Діаграма синхронізації (Timing Diagram)\n
Діаграма діяльності (Activity Diagram)\n
Діаграма прецедентів (Use case diagram)\n
Діаграма станів (State Machine diagram)</item>
        <item>Діаграма Прецедентів візуально зображає різноманітні сценарії взаємодії між акторами (користувачами) і прецедентами (випадками використання); описує функціональні аспекти системи (бізнес логіку).\n
         Діаграми Прецедентів відіграють важливу роль не тільки у комунікації між збирачами вимог до проекту і потенційними користувачами.\n
      Діаграми Прецедентів дописані бізнес логікою і детальними специфікаціями прецедентів, як джерельна інформація, успішно використовують учасники розробки проекту на всіх його фазах (зародження, дизайн, програмування, тестування, документування).\n
        Добре продумані і завершені специфікації прецедентів легко перевтілюються у Тестові Випадки.\n
Елементи Діаграми Прецедентів:\n
Актор — користувач.\n
Прецедент — випадок використання, дія. Позначається овалом.\n
Граничні межі системи — охоплюють усі випадки використання у системі.     Позначається     прямокутником.\n
Елементи взаємодії Діаграми Прецедентів:\n
    Використовує — користувач виконує дію.\n
    Включає — один прецедент використовує іншого.\n
    Розширює — представлення дочірніх прецедентів.\n
    Вимагає — наступний прецедент вимагає виконання попереднього.\n
    Схожий — прецеденти подібні, але описують різну функціональність.\n
    Рівнозначний — подібна функціональність, але користувач сприймає, як різну.</item>
    </string-array>
    <array name="uml_image_array">
        <item>@drawable/uml</item>
        <item>@drawable/diagrams</item>
        <item>@drawable/use_case</item>
    </array>

    <string-array name="Cases">
        <item>Test Cases</item>
        <item>Test Cases Structural Elements</item>
        <item>Test Case Creation Guidelines</item>
        <item>Test Case Templates</item>

           </string-array>
    <string-array name="Cases_content">
        <item>Це документ, що описує сукупність кроків, конкретних умов і параметрів, необхідних для перевірки реалізації тестованої функції або її частини.</item>
        <item>Основні елементи тест кейсу:\n
ID\n
Name/Summary/Title\n
Pre-conditions\n
Description (Steps)\n
Post-conditions\n
Reference\n
Data\n
Expected Results\n
Actual Results\n
Attachments\n
Comments\n
Tools\n
Priority\n
Status\n
ID – ідентифікатор має бути унікальним.\n
Name/ Summary/ Title – ім’я, короткий зміст чи назва. Назва повинна бути короткою та інформативною, щоб розкривати суть тест кейсу без його повного прочитання.\n
Pre-conditions – передумови або що має бути виконане до виконання тест кейсу.\n
Description – це опис тест кейсу, зазвичай являє собою або включає кроки для відтворення. Це найважливіша обов’язкова частина тест кейсу.\n
Post-conditions – післяумови або що має бути виконане після виконання тест кейсу. Після тест кейсу рекомендовано повертати систему у початковий, чистий або інший початковий стан.\n
Reference – посилання на джерела тест кейсу (вимоги, тест дизайн, інше) а також на інші пов’язані тест кейси.\n
Data – дані, що мають бути використані в тест кейсі під час тестування.\n
Expected Results – очікувані результати згідно вимог, очікувань клієнта чи здорового глузду.\n
Actual Results – реальні отримані результати під час тестування.\n
Attachments – додатки картинок екрану, відео, файлів, логів і т.д., що може бути використане, як наявний доказ поведінки системи.\n
Comments – коментарі, додаткова важлива інформація.\n
Priorities – приоритетність.\n
High - високий\n
Medium – середній\n
Normal – нормальний\n
Low – низький\n
Status – статуси асоційовані із тест кейсами:\n
Passed – виконано\n
Successfully tested – успішно протестовано\n
Failed – знайдено помилку, отриманий результат не відповідає очікуваному.\n
Blocked – заблокований, в коментарі необхідно вказати причину.\n
Not Applicable – не виконується, в коментарі необхідно вказати причину.\n
Postponed – відкладений, в коментарі необхідно     вказати причину.</item>
        <item>Чому потрібні тест кейси?\n
Тест кейси розробляються з метою перевірки системи оптимальною кількістю тестових випадків.\n
Що необхідно зробити до написання тест кейсів?\n
уважно прочитати і дослідити вимоги до продукту;\n
чітко розуміти цілі розробки продукту;\n
проаналізувати та розробити дизайн необхідних сценаріїв для максимально оптимального покриття системи тестовими випадками;\n
визначити середовище для проведення тестів;\n
розробити стратегію тестування та визначитись із видами тестування;\n
з’ясувати функціональні та інші залежності у системі;\n
передбачити     поведінку системи на випадок некоректної     поведінки користувача чи інші можливі     некоректні умови.\n
Параметри якісних тест кейсів?\n
Результати легко визначаються\n
   Очікуваний результат повинен бути чітким, помітним, зрозумілим та його можна легко інтерпретувати.\n
Тести виконуються швидко\n
    Тестові випадки повинні  містити якогомога меншу кількість кроків, по можливості, та повинні швидко проводитися.\n
Зрозумілий кожному опис кроків\n
     Тест кейси повинні бути описаними у достатньо зрозумілий та доступний спосіб, щоб інший інженер зміг виконати його без вникання у вимоги до продукту.\n
Крос-платформенний\n
     Тест повинен бути крос-платформенним. Таким, що може бути виконаним у різних середовищах, на стільки, на скільки це можливо.</item>
        <item>Test Case Specification Template (IEEE 829-1998)\n
            Test Case Specification Identifier\n
ідентифікатор специфікації тест кейсів;\n
унікальний номер згенерований компанією;\n
унікальне коротке ім’я тест кейсу;\n
дата і номер версії тестового випадку;\n
автор версії і його контактна інформація;\n
історія переглядів та змін.\n
Test Items\n
      Тестові об’єкти, які підлягають тестуванню чи що саме буде тестуватися, який продукт, яка функціональність, чи фукнція, інше.\n
References\n
      Посилання. Джерела інформації, які використовувались для формування тестових випадків.\n
Input Specifications\n
      Cпецифікації / вказівки для введення даних.\n
Output Specifications\n
      Специфікації / вказівки для виведення даних\n
Environmental needs\n
      Потреби середовища — опис середовища, в якому повинно відбуватися тестування.\n
Special Procedural Requirements\n
      Спеціальні процедурні вимоги.\n
Inter-case Dependencies\n
     Залежності між певними випадками.</item>
    </string-array>
    <array name="Cases_image_array">
        <item>@drawable/test_cases</item>
        <item>@drawable/structural</item>
        <item>@drawable/creation_</item>
        <item>@drawable/templates</item>

    </array>







</resources>